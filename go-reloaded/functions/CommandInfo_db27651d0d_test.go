// Test generated by RoostGPT for test go-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k


/*
1. Test when the input string `s` is "(up)", the function should return "up", 1.
2. Test when the input string `s` is "(hex)", the function should return "hex", 1.
3. Test when the input string `s` is "(bin)", the function should return "bin", 1.
4. Test when the input string `s` is "(low)", the function should return "low", 1.
5. Test when the input string `s` is "(cap)", the function should return "cap", 1.
6. Test when the input string `s` is empty, the function should return "DIDARS_GOOD_JOKE", 0.
7. Test when the input string `s` contains "(hex,123)", the function should return "hex", 123.
8. Test when the input string `s` contains "(low,45)", the function should return "low", 45.
9. Test when the input string `s` contains "(cap,678)", the function should return "cap", 678.
10. Test when the input string `s` contains "(up,90)", the function should return "up", 90.
11. Test when the input string `s` contains "(bin,32)", the function should return "bin", 32.
12. Test when the input string `s` does not contain a number separated by comma, it should return "DIDARS_GOOD_JOKE", 0.
13. Test when the input string `s` does not start with any predefined commands (up, hex, bin, low, cap) and contains a number separated by comma, the function should return "DIDARS_GOOD_JOKE" with the number as integer.
14. Test when the input string `s` starts with one of the predefined commands but does not contain a number separated by comma, it should return the command and 0. 
15. Test when the input string `s` is more than 4 characters but does not start with a parenthesis, the function should return "DIDARS_GOOD_JOKE", 0. 
16. Test when the input string `s` is a command followed by the wrong separator, it should return "DIDARS_GOOD_JOKE", 0. 
17. Test when the input string `s` contains non-numeric characters after the comma separator, the function should return "DIDARS_GOOD_JOKE", 0.
*/
package reloaded

import (
	"regexp"
	"strconv"
)


func CommandInfo(s string) (string, int) {
    out_str := "DIDARS_GOOD_JOKE"
    if s[:3] == "(up" {
        out_str = "up"
    }
    if s[:4] == "(hex" {
        out_str = "hex"
    }
    if s[:4] == "(bin" {
        out_str = "bin"
    }
    if s[:4] == "(low" {
        out_str = "low"
    }
    if s[:4] == "(cap" {
        out_str = "cap"
    }

    dig := regexp.MustCompile(`,\d+\)`)
    out_int := 0

    if s == "(up)" || s == "(hex)" || s == "(bin)" || s == "(low)" || s == "(cap)" {
        out_int = 1
    } else {
        temp := dig.Find([]byte(s))
        if temp != nil {
            out_int, _ = strconv.Atoi(string(temp[1 : len(temp)-1]))
        }
    }

    return out_str, out_int
}


import (
	"testing"
)

func TestCommandInfo_db27651d0d(t *testing.T) {
	var tests = []struct {
		input    string
		expectedStr string
		expectedInt int
	}{
		{"(up)", "up", 1},
		{"(hex)", "hex", 1},
		{"(bin)", "bin", 1},
		{"(low)", "low", 1},
		{"(cap)", "cap", 1},
		{"", "DIDARS_GOOD_JOKE", 0},
		{"(hex,123)", "hex", 123},
		{"(low,45)", "low", 45},
		{"(cap,678)", "cap", 678},
		{"(up,90)", "up", 90},
		{"(bin,32)", "bin", 32},
		{"hello,123)", "DIDARS_GOOD_JOKE", 0},
		{"random,52", "DIDARS_GOOD_JOKE", 52},
        {"(hex", "hex", 0},
		{"hello world", "DIDARS_GOOD_JOKE", 0},
		{"(up;42)", "DIDARS_GOOD_JOKE", 0},
		{"(low,abc)", "DIDARS_GOOD_JOKE", 0},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			str, digit := CommandInfo(tt.input)
			if str != tt.expectedStr || digit != tt.expectedInt {
				t.Errorf("got '%s' '%d', want '%s' '%d'", str, digit, tt.expectedStr, tt.expectedInt)
			}
		})
	}
}
