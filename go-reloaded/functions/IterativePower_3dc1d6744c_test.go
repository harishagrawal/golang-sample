// Test generated by RoostGPT for test go-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

/*
1. Test with positive numbers as inputs for nb and power, i.e, IterativePower(2, 3). The expected output should be the result of 2 to the power 3 which is 8.

2. Test with zero as input for nb and a positive number for power, i.e, IterativePower(0, 5). The expected output should be 0 as zero powered to any positive number remains 0.

3. Test with zero as the power input and a positive number for nb, i.e, IterativePower(5, 0). The expected output should be 1 as any number to the power of zero is 1.

4. Test with negative number as nb and positive number as power, i.e, IterativePower(-2, 3). The expected output should be -8 as -2 to the power 3 results in -8.

5. Test with negative number as power and positive number as nb, i.e, IterativePower(5, -3). The expected outcome should be 0 because the function is designed to return 0 in case of negative power.

6. Test with both nb and power being 0, i.e, IterativePower(0, 0). The expected outcome should be 1 as any number to the power 0 is usually considered as 1.

7. Test with larger numbers for both nb and power to check if the function can handle it accurately without causing an overflow.

8. Test with large power and small nb to see how the function handles long iterations.

9. Test with nb as 1 and power as any positive number, i.e, IterativePower(1, 1000). The result should always be 1.

10. Test with values like IterativePower(2, 10), IterativePower(3, 4) etc. and compare the result with the inbuilt pow function in Go to check for any discrepancy.
*/
package reloaded

import (
	"math"
	"strconv"
	"testing"
)

func TestIterativePower_3dc1d6744c(t *testing.T) {
	var tests = []struct {
		nb       int
		power    int
		expected int
	}{
		{2, 3, 8},
		{0, 5, 0},
		{5, 0, 1},
		{-2, 3, -8},
		{5, -3, 0},
		{10, 10, 1000000000},
		{1, 1000, 1},
		{2, 10, 1024},
		{3, 4, 81},
		{0, 0, 1},
	}

	for _, tt := range tests {
		testname := string(tt.nb) + " powered to " + string(tt.power)
		t.Run(testname, func(t *testing.T) {
			ans := IterativePower(tt.nb, tt.power)
			if ans != tt.expected {
				t.Errorf("got %d, expected %d", ans, tt.expected)
			} else {
				t.Logf("success: for inputs nb: %d and power: %d, expected output: %d, got: %d", tt.nb, tt.power, tt.expected, ans)
			}
		})
	}
}

// additional test to validate against math.Pow function from go standard library
func TestIterativePowerAgainstMathPow(t *testing.T) {
	for i := -10; i <= 10; i++ {
		for j := 0; j <= 10; j++ {
			t.Run("Testing with values "+strconv.Itoa(i)+" and "+strconv.Itoa(j), func(t *testing.T) {
				actual := IterativePower(i, j)
				expected := int(math.Pow(float64(i), float64(j)))
				if actual != expected {
					t.Errorf("TestIterativePower failed: got %v want %v", actual, expected)
				} else {
					t.Logf("success: for inputs nb: %d and power: %d, expected output: %d, got: %d", i, j, expected, actual)
				}
			})
		}
	}
}
