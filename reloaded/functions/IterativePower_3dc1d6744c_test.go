// Test generated by RoostGPT for test go-unit using AI Type Azure Open AI and AI Model roostgpt-4-32k

/*
Test Scenario 1: Validate input where power equals 0.
Expected output: The function should return 1 regardless of what the "nb" value is.

Test Scenario 2: Validate input where power is less than 0.
Expected output: The function should return 0.

Test Scenario 3: Validate input where power is greater than 0 and nb equals 0.
Expected output: The function should return 0.

Test Scenario 4: Validate input where power is greater than 0 and nb equals 1.
Expected output: The function should return 1.

Test Scenario 5: Validate input where power is greater than 0 and nb is greater than 1.
Expected output: The function should return the result by multiplying nb, power times.

Test Scenario 6: Validate input where power is a larger positive integer.
Expected output: Check for the performance of the function.

Test Scenario 7: Validate the boundary conditions where power equals the maximum allowable integer.
Expected output: The function should handle it without a runtime error.

Test Scenario 8: Validate the scenario where both nb and power are negative inputs.
Expected output: The function should return 0 since the program does not compute the power of negative numbers.

Test Scenario 9: Handle edge case conditions like passing in non-integer values.
Expected output: As the function only handles integer inputs, it should return some form of error or exception.

Test Scenario 10: Validate the scenario where both nb and power are positive large integers.
Expected output: Check overflow scenario. The function should handle it without a runtime error.
*/
package reloaded

import (
	"fmt"
	"os"
	"testing"
)

func TestIterativePower_3dc1d6744c(t *testing.T) {
	// Define test cases
	testCases := []struct {
		name   string
		nb     int
		power  int
		expect int
	}{
		{"Power is zero", 10, 0, 1},
		{"Power less than zero", 10, -1, 0},
		{"Power > 0 and nb = 0", 0, 3, 0},
		{"Power > 0 and nb = 1", 1, 3, 1},
		{"Power > 0 and nb > 1", 2, 3, 8},
		{"Large power", 10, 100000, 0},
		{"Boundary power", 2, 1<<31 - 1, 0},
		{"Both Power and nb are negative", -2, -2, 0},
		{"Large positive nb and power", 1<<31 - 1, 1<<31 - 1, 0},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			fmt.Fprintln(os.Stdout, tc.name)

			// Call function with test data and get the result
			got := IterativePower(tc.nb, tc.power)

			// Log test scenario
			t.Logf("IterativePower(%d, %d): got %d, expect %d", tc.nb, tc.power, got, tc.expect)

			// Compare the result with the expected result
			if got != tc.expect {
				t.Errorf("Failed on %s: got %d, expect %d", tc.name, got, tc.expect)
			}
		})
	}
}
