// ********RoostGPT********
/*
Test generated by RoostGPT for test go-gpt4-unit-may23 using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=IterativePower_9b63d88a1f
ROOST_METHOD_SIG_HASH=IterativePower_3dc1d6744c

Scenario 1: Test with positive power

Details:
    Description: This test is meant to check the IterativePower function when a positive power is provided. The function should correctly compute the power of the number.
Execution:
    Arrange: No setup required.
    Act: Invoke the IterativePower function with a number and a positive power.
    Assert: Assert that the returned result matches the expected output.
Validation:
    The assertion validates that the function correctly computes the power of a number when the power is positive. This is important to ensure the correct mathematical calculation of the function.

Scenario 2: Test with zero power

Details:
    Description: This test is meant to check the IterativePower function when the power is zero. The function should return 1 irrespective of the number as any number raised to the power of zero is one.
Execution:
    Arrange: No setup required.
    Act: Invoke the IterativePower function with a number and zero as power.
    Assert: Assert that the returned result is 1.
Validation:
    The assertion validates that the function correctly handles the case when the power is zero. This is critical as it is a fundamental rule in mathematics that any number raised to the power of zero is one.

Scenario 3: Test with negative power

Details:
    Description: This test is meant to check the IterativePower function when the power is negative. The function should return 0 as it does not handle negative powers.
Execution:
    Arrange: No setup required.
    Act: Invoke the IterativePower function with a number and a negative power.
    Assert: Assert that the returned result is 0.
Validation:
    The assertion validates that the function correctly handles the case when the power is negative. This is crucial as the function is designed to not handle negative powers.

Scenario 4: Test with large power

Details:
    Description: This test is meant to check the IterativePower function when a large power is provided. The function should correctly compute the power of the number, or return an overflow value if the result is too large for an int.
Execution:
    Arrange: No setup required.
    Act: Invoke the IterativePower function with a number and a large power.
    Assert: Assert that the returned result matches the expected output or an overflow value.
Validation:
    The assertion validates that the function correctly handles the case when the power is large. This is important for ensuring the function behaves correctly under extreme conditions.
*/

// ********RoostGPT********
package reloaded

import (
	"testing"
)

func TestIterativePower(t *testing.T) {
	// Define the test cases
	testCases := []struct {
		name   string
		input  int
		power  int
		output int
	}{
		{"Positive power", 2, 3, 8},
		{"Zero power", 2, 0, 1},
		{"Negative power", 2, -1, 0},
		{"Large power", 2, 31, 1 << 31},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Act
			result := IterativePower(tc.input, tc.power)

			// Assert
			if result != tc.output {
				t.Errorf("IterativePower(%d, %d) = %d; want %d", tc.input, tc.power, result, tc.output)
			} else {
				t.Logf("IterativePower(%d, %d) = %d; passed", tc.input, tc.power, result)
			}
		})
	}
}
