// ********RoostGPT********
/*
Test generated by RoostGPT for test go-gpt4-unit-may23 using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=IterativePower_9b63d88a1f
ROOST_METHOD_SIG_HASH=IterativePower_3dc1d6744c

Scenario 1: Test with positive power

Details:
    Description: This test is meant to check the IterativePower function when a positive power is provided. The function should correctly compute the power of the number.
Execution:
    Arrange: No setup is required as the function does not depend on any external state.
    Act: Invoke the IterativePower function with a positive integer and a positive power.
    Assert: Use Go testing facilities to verify that the actual results match the expected outcomes.
Validation:
    The choice of assertion is to compare the result of the function with the expected result of the power operation. The expected result can be computed in advance or using a trusted library function. This test is important to verify that the function correctly handles the most common case.

Scenario 2: Test with zero power

Details:
    Description: This test is meant to check the IterativePower function when the power is zero. According to mathematical rules, any number raised to the power of zero should return 1.
Execution:
    Arrange: No setup is required as the function does not depend on any external state.
    Act: Invoke the IterativePower function with a positive integer and a power of zero.
    Assert: Use Go testing facilities to verify that the actual results match the expected outcomes.
Validation:
    The choice of assertion is to check that the result of the function is 1, regardless of the base number. This test is important to verify that the function correctly implements the mathematical rule of zero power.

Scenario 3: Test with negative power

Details:
    Description: This test is meant to check the IterativePower function when the power is negative. The function is expected to return 0 in this case, as it does not handle negative powers.
Execution:
    Arrange: No setup is required as the function does not depend on any external state.
    Act: Invoke the IterativePower function with a positive integer and a negative power.
    Assert: Use Go testing facilities to verify that the actual results match the expected outcomes.
Validation:
    The choice of assertion is to check that the result of the function is 0, regardless of the base number. This test is important to verify that the function correctly handles cases where the power is negative.

Scenario 4: Test with large power

Details:
    Description: This test is meant to check the IterativePower function when the power is a large number. This will test the performance and correctness of the function under extreme conditions.
Execution:
    Arrange: No setup is required as the function does not depend on any external state.
    Act: Invoke the IterativePower function with a small positive integer and a large power.
    Assert: Use Go testing facilities to verify that the actual results match the expected outcomes.
Validation:
    The choice of assertion is to compare the result of the function with the expected result of the power operation. The expected result can be computed in advance or using a trusted library function. This test is important to verify that the function can handle large powers without overflow or other errors.
*/

// ********RoostGPT********
package reloaded

import (
	"testing"
)

func TestIterativePower(t *testing.T) {
	testCases := []struct {
		nb     int
		power  int
		expect int
	}{
		{
			nb:     2,
			power:  3,
			expect: 8,
		},
		{
			nb:     5,
			power:  0,
			expect: 1,
		},
		{
			nb:     3,
			power:  -2,
			expect: 0,
		},
		{
			nb:     2,
			power:  10,
			expect: 1024,
		},
	}

	for _, tc := range testCases {
		t.Run("", func(t *testing.T) {
			result := IterativePower(tc.nb, tc.power)
			if result != tc.expect {
				t.Errorf("IterativePower(%d, %d) = %d; expected %d", tc.nb, tc.power, result, tc.expect)
			}
		})
	}
}
